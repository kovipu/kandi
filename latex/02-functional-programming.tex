\chapter{Functional programming} \label{Functional programming}

% Functional programming paradigm
% - Based on lambda calculus
% - A bit of history

% - The paradigm
\section{Definition}
Functional programming is a computer programming paradigm in which the evaluation of a computer program is carried out
through the evaluation of deeply nested mathematical functions. Declarative programming is a programming paradigm that
describes the program only as expressions or declarations instead of statements. Functional programming is a declarative
programming paradigm that describes the program as function declarations. Functional code avoids changing-state and
mutable data, which can make understanding a program easier.\cite{hudak}

\section{Lambda calculus}
Functional programming is largely based on lambda calculus, a formal system originally developed in 1928 by Alonzo
Church. Lambda calculus is widely regarded as the first functional programming language, althought it was conceived
before the first actual computers and therefore not seen as a computer programming language at its time. Many modern
functional programming languages, such as Lisp, can be seen as abstractions on top of lambda calculus. Lambda calculus
can also be written as $\lambda$-calculus with the Greek letter lambda.\cite{hudak}

The most simple form of lambda calculus consists of only three operations: variables, abstractions and applications.
Variables are simply characters or strings representing a parameter or a value. However Church's original Lambda
calculus did not include free variables, only ones bound to function application. His two primitives included
abstraction and application. Abstraction $\lambda x [ M ] $ defines a function with variable x and lambda term M.
Application $ \{ F \} ( X ) $ applies value X to function F.\cite{lambdacalculus}

% - modern lambda calculus

\section{Concepts}
% * declarative?

\subsection{Immutability}
Declarative programming languages have no implicit state which contrasts to imperative languages where the state is
modified by constructs (i.e. commands) in the program code. This makes computations only possible with expressions (or
terms). Functional programming languages in particular use the function as their basis of computation. For instance this
contrasts to logic programming where such construct would the relation. This makes loops nonexistent in pure functional
programming. For example, computing the factorial of the number n could be implemented in an imperative language like
Python:
\begin{minted}{python}
def factorial(n):
    result = 1
    while n >= 1:
        result = result * n
        n = n - 1
    return result
\end{minted}
With a functional programming language, the repetition has to be implemented using recursion. Functional programming
languages allow functions to be recursive and, more often than not, make implmenting it easy. Computing the factorial
of the number n in a functional programming language using recursion could be implemented, for example, like this in
Haskell:
\begin{minted}{haskell}
factorial n = if n < 2
                then 1
                else n * factorial (n-1)
\end{minted}
\cite{hudak}
% add reasons why this is a good idea, i.e. side-effects

\subsection{Higher order functions}
Functional programming languages promote functional programming by allowing higher order functions. This means functions
are treated as first-class values and they are allowed as parameters to a function, returned as a result or stored in
data structures.\cite{hudak} For example, the map function is often used to render a list of items in modern web
front-end.\cite{functionalreact} For example, rendering a list of items using the map function in React:
\begin{minted}{jsx}
<div className="items">
  {items.map(item => <Item {...item} />)}
</div>
\end{minted}

\subsection{Lazy evaluation}
Lazy evaluation is an evaluation strategy where a value of an expression is only computed when its value is needed, and
that value is stored for later use. This can reduce the computation time of functions and therefore improve program
performance by an exponential factor over other types of evaluation strategies. Eager evaluation means the value is
computed on its first point of call. This is the evaluation strategy of most programming languages. Lazy evaluation is
only implemented by pure functional languages like Haskell.\cite{languagedesign}

\subsection{Pattern matching and data-abstractions}
% these are typical for a purely functional language

\section{Languages}
% - Lisp vs ML
% - Modern functional languages. Clojure, Haskell etc

